#!/bin/bash

################################################################################
# build_sdk.sh - Automated iOS SDK Patcher
#
# This script automates the creation of patched iOS SDKs by:
# 1. Downloading and extracting Xcode
# 2. Automatically determining the correct iOS SDK version
# 3. Downloading the matching IPSW file
# 4. Extracting the dyld shared cache from the IPSW
# 5. Creating a patched SDK using the Theos toolchain
#
# Requirements: macOS with Homebrew installed
# Usage: ./create_sdk.sh [OPTIONS]
################################################################################

set -euo pipefail

################################################################################
# Configuration & Global Variables
################################################################################

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Path to the dynamic Xcode↔iOS SDK map (generated by map_sdks.py)
SDK_MAP_FILE="${SCRIPT_DIR}/sdk_map.json"

# Temporary directories (will be cleaned up)
TEMP_DIRS=()

# Mounted volumes (will be unmounted)
MOUNTED_VOLS=()

# Script parameters (defaults)
IOS_VERSION=""   # Primary input - user specifies this
XCODE_VERSION="" # Will be auto-determined from iOS version
IPSW_DEVICE=""   # Will be auto-selected
DSC_BASENAME="dyld_shared_cache_arm64e"
XCRUN_SDK_NAME="iphoneos"
FULL_SDK_NAME="" # Will be auto-generated as iPhoneOS{version}

# Tool paths
TBD_TOOL_PATH=""
SDK_OUTPUT_PATH=""
DSC_EXTRACTOR_CLIENT_PATH=""  # path to compiled dsc_extractor_client binary

# Resolved at runtime (may change when auto-detecting DSC arch)
RESOLVED_DSC_BASENAME=""      # the actual dyld_shared_cache_* name found on disk
PLATFORM_PATH=""              # xcrun --show-sdk-platform-path

# Work dir (set per-run so --all can use separate dirs per version)
WORK_DIR=""

# Flags
ALL_VERSIONS=false

################################################################################
# Colors for output
################################################################################

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

################################################################################
# Logging Functions
################################################################################

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_step() {
    echo ""
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN}$*${NC}"
    echo -e "${GREEN}========================================${NC}"
}

log_skip() {
    echo -e "${CYAN}[SKIP]${NC} $*"
}

################################################################################
# Cleanup Handler
#
# FIX: "${arr[@]}" under set -u crashes when the array is declared-but-empty
# on bash 3.x/4.x (the default macOS shell used by GitHub runners).
# Guard every array iteration with the ${arr[@]+"${arr[@]}"} idiom, which
# expands to nothing (rather than triggering the "unbound variable" error)
# when the array is empty.
################################################################################

cleanup() {
    local exit_code=$?

    log_info "Cleaning up..."

    # Unmount all mounted volumes
    for vol in "${MOUNTED_VOLS[@]+"${MOUNTED_VOLS[@]}"}"; do
        if [ -d "${vol}" ]; then
            log_info "Unmounting ${vol}"
            hdiutil detach "${vol}" 2>/dev/null || true
        fi
    done

    # Remove temporary directories
    for dir in "${TEMP_DIRS[@]+"${TEMP_DIRS[@]}"}"; do
        if [ -d "${dir}" ]; then
            log_info "Removing temporary directory ${dir}"
            rm -rf "${dir}"
        fi
    done

    if [ "${exit_code}" -ne 0 ]; then
        log_error "Script failed with exit code ${exit_code}"
    else
        log_success "Cleanup complete"
    fi

    exit "${exit_code}"
}

trap cleanup EXIT INT TERM

################################################################################
# Per-version state reset (used in --all mode between iterations)
################################################################################

reset_version_state() {
    IOS_VERSION=""
    XCODE_VERSION=""
    IPSW_DEVICE=""
    FULL_SDK_NAME=""
    SDK_OUTPUT_PATH=""
    TBD_TOOL_PATH=""
    WORK_DIR=""
    PLATFORM_PATH=""
    RESOLVED_DSC_BASENAME=""
    DYLD_CACHE_PATH=""
    # DSC_EXTRACTOR_CLIENT_PATH is intentionally NOT reset — the binary is
    # shared across all versions and only needs to be compiled once.

    # Unmount any leftover volumes from the previous iteration
    for vol in "${MOUNTED_VOLS[@]+"${MOUNTED_VOLS[@]}"}"; do
        if [ -d "${vol}" ]; then
            hdiutil detach "${vol}" 2>/dev/null || true
        fi
    done
    MOUNTED_VOLS=()

    # Remove leftover temp dirs from the previous iteration
    for dir in "${TEMP_DIRS[@]+"${TEMP_DIRS[@]}"}"; do
        if [ -d "${dir}" ]; then
            rm -rf "${dir}"
        fi
    done
    TEMP_DIRS=()
}

################################################################################
# Tool Installation Functions
################################################################################

check_homebrew() {
    if ! command -v brew &> /dev/null; then
        log_error "Homebrew is not installed"
        log_info "Please install Homebrew from https://brew.sh/"
        exit 1
    fi
    log_success "Homebrew is installed"
}

check_and_install_tool() {
    local tool=$1
    local install_cmd=$2

    if command -v "${tool}" &> /dev/null; then
        log_success "${tool} is already installed"
        return 0
    fi

    log_warn "${tool} is not installed. Installing..."
    if eval "${install_cmd}"; then
        log_success "${tool} installed successfully"
    else
        log_error "Failed to install ${tool}"
        exit 1
    fi
}

install_required_tools() {
    log_step "Checking and Installing Required Tools"

    check_homebrew

    check_and_install_tool "unxip"  "brew install unxip"
    check_and_install_tool "xcodes" "brew install xcodesorg/made/xcodes"
    check_and_install_tool "ipsw"   "brew install ipsw"
    check_and_install_tool "aria2c" "brew install aria2"

    log_success "All required tools are installed"
}

################################################################################
# Input Validation Functions
################################################################################

validate_ios_version() {
    local ver="$1"
    if [[ ! "${ver}" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
        return 1
    fi
    return 0
}

validate_inputs() {
    log_step "Validating Input Parameters"

    if [ -z "${IOS_VERSION}" ]; then
        log_error "iOS version is required"
        exit 1
    fi

    if ! validate_ios_version "${IOS_VERSION}"; then
        log_error "Invalid iOS version format: ${IOS_VERSION}"
        log_info "iOS version should be in format like: 9.3, 18.2, 26.0"
        exit 1
    fi

    if ! xcode_for_ios_sdk "${IOS_VERSION}" > /dev/null 2>&1; then
        log_error "iOS SDK ${IOS_VERSION} is not in the known version table."
        log_info "Run '$(basename "$0") --help' to see all supported versions."
        exit 1
    fi

    log_success "Input parameters validated: iOS ${IOS_VERSION}"
}

################################################################################
# Interactive Input Functions
################################################################################

prompt_for_inputs() {
    echo ""
    log_info "Please provide the following information:"
    echo ""

    if [ -z "${IOS_VERSION}" ]; then
        echo "Enter the iOS version you want to target:"
        echo ""
        echo "Examples of iOS versions:"
        echo "  - 26.3 (latest as of Feb 2026)"
        echo "  - 18.2 (iOS 18)"
        echo "  - 17.4 (iOS 17)"
        echo "  - 16.5 (iOS 16)"
        echo ""
        echo "Note: Apple uses year-based versioning since 2025 (skipped iOS 19-25)"
        echo ""
        read -p "iOS version: " IOS_VERSION
    fi

    echo ""
    log_info "Configuration:"
    echo "  iOS Version: ${IOS_VERSION}"
    echo "  Xcode:       Will be auto-selected"
    echo "  Device:      Will be auto-selected"
    echo "  Output SDK:  iPhoneOS${IOS_VERSION}.sdk"
    echo ""

    read -p "Continue with these settings? (y/n): " confirm
    if [[ ! "${confirm}" =~ ^[Yy]$ ]]; then
        log_info "Aborted by user"
        exit 0
    fi
}

################################################################################
# All-versions helpers
################################################################################

# Ensure sdk_map.json is available locally.
# If missing, attempt to download it from the repo's main branch.
ensure_sdk_map() {
    if [ -f "${SDK_MAP_FILE}" ]; then
        return 0
    fi

    log_warn "sdk_map.json not found at: ${SDK_MAP_FILE}"

    # Try to generate it on-the-fly using map_sdks.py (requires Python + pip deps)
    local map_sdks_script="${SCRIPT_DIR}/map_sdks.py"
    if [ -f "${map_sdks_script}" ] && command -v python3 &>/dev/null; then
        log_info "Attempting to generate sdk_map.json via map_sdks.py …"
        if python3 -m pip install --quiet requests beautifulsoup4 2>/dev/null && \
           python3 "${map_sdks_script}" --json "${SDK_MAP_FILE}" 2>/dev/null || true; then
            log_success "Generated ${SDK_MAP_FILE}"
            return 0
        fi
    fi

    log_error "Cannot find or generate ${SDK_MAP_FILE}."
    log_info  "Run:  python3 map_sdks.py"
    log_info  "Or download it from the repository and place it next to this script."
    exit 1
}

# Returns the recommended Xcode version for a given iOS SDK version.
# Reads from sdk_map.json (generated by map_sdks.py).
# Exits 1 (causing a skip in --all mode) if the SDK is not in the map.
xcode_for_ios_sdk() {
    local sdk="$1"
    ensure_sdk_map

    python3 - "${SDK_MAP_FILE}" "${sdk}" << 'PYEOF'
import json, sys

map_file = sys.argv[1]
ios_sdk  = sys.argv[2]

try:
    with open(map_file) as f:
        data = json.load(f)
except Exception as e:
    print(f"ERROR reading {map_file}: {e}", file=sys.stderr)
    sys.exit(1)

def ver_key(v):
    try:
        return [int(x) for x in v.split(".")]
    except ValueError:
        return [0]

# data is a flat dict: {xcode_version: ios_sdk}
# Find all Xcode versions that ship this iOS SDK
candidates = [
    xcode_ver
    for xcode_ver, sdk in data.items()
    if sdk == ios_sdk
]

if not candidates:
    sys.exit(1)

# Pick the smallest (= earliest Xcode that first shipped this SDK)
candidates.sort(key=ver_key)
print(candidates[0])
PYEOF
}

# Returns all known iOS SDK versions >= 9.3, oldest-to-newest, one per line.
# Reads from sdk_map.json (generated by map_sdks.py).
all_known_ios_sdks() {
    ensure_sdk_map

    python3 - "${SDK_MAP_FILE}" << 'PYEOF'
import json, sys

map_file = sys.argv[1]

try:
    with open(map_file) as f:
        data = json.load(f)
except Exception as e:
    print(f"ERROR reading {map_file}: {e}", file=sys.stderr)
    sys.exit(1)

def ver_key(v):
    try:
        return [int(x) for x in v.split(".")]
    except ValueError:
        return [0]

MIN_IOS = [9, 3]

# data is a flat dict: {xcode_version: ios_sdk}
# Collect unique iOS SDK versions >= 9.3
seen = set()
versions = []
for sdk in data.values():
    if not sdk or sdk in seen:
        continue
    try:
        if [int(x) for x in sdk.split(".")] >= MIN_IOS:
            seen.add(sdk)
            versions.append(sdk)
    except ValueError:
        pass

versions.sort(key=ver_key)
for v in versions:
    print(v)
PYEOF
}

# Returns the static list of all known iOS SDK versions >= 9.3.
get_all_ios_versions() {
    all_known_ios_sdks
}

# Return 0 if the final SDK already exists on disk for a given iOS version
sdk_already_exists() {
    local ver="$1"
    local sdk_path="${SCRIPT_DIR}/iPhoneOS${ver}.sdk"
    [ -d "${sdk_path}" ]
}

################################################################################
# Xcode Management Functions
################################################################################

# Probe all Xcodes currently installed under /Applications and return the path
# of the first one whose bundled iOS SDK major matches the required version.
# Prints the app path to stdout; returns 1 if none found.
# Shared post-setup: set DEVELOPER_DIR, accept licence, mark whether we own it.
# $1 = path to Xcode.app   $2 = "owned" | "preinstalled"
_setup_xcode_app() {
    local app_path="$1"
    local ownership="$2"

    export DEVELOPER_DIR="${app_path}"
    XCODE_WAS_PREINSTALLED=false
    [ "${ownership}" = "preinstalled" ] && XCODE_WAS_PREINSTALLED=true

    log_info "Accepting Xcode license (requires sudo)..."
    sudo DEVELOPER_DIR="${DEVELOPER_DIR}" xcodebuild -license accept 2>/dev/null || true
    log_success "Using Xcode at: ${app_path}"
}

# Set to true when we reuse a pre-installed Xcode so remove_xcode skips it.
XCODE_WAS_PREINSTALLED=false

download_and_extract_xcode() {
    log_step "Step 3: Locating / Downloading Xcode ${XCODE_VERSION}"

    # ── 1. Exact version already installed? (versioned app name) ─────────────
    local xcode_app="/Applications/Xcode_${XCODE_VERSION}.app"
    if [ -d "${xcode_app}" ]; then
        log_success "Xcode ${XCODE_VERSION} already installed at ${xcode_app}"
        _setup_xcode_app "${xcode_app}" "preinstalled"
        return 0
    fi

    # ── 2. Resolve exact xcodes version string ────────────────────────────────
    # xcodes stores versions with qualifiers: "11.5 GM", "14.3 Release Candidate"
    # etc. Passing just "11.5" returns "Could not find version". Query the list
    # first and pick the best match: prefer GM/Release Candidate over Beta,
    # and exact number match over partial.
    log_info "Resolving exact xcodes version string for ${XCODE_VERSION}..."

    local xcodes_version_str
    xcodes_version_str=$(xcodes list 2>/dev/null \
        | grep -E "^[[:space:]]*${XCODE_VERSION}([[:space:](]|$)" \
        | grep -v 'Beta\|Seed' \
        | tail -1 \
        | sed 's/ ([^)]*)$//' \
        | sed 's/^[[:space:]]*//' \
        | sed 's/[[:space:]]*$//' \
        || true)

    # If no non-beta match found, fall back to any match (handles cases where
    # only a beta was ever released for that version number)
    if [ -z "${xcodes_version_str}" ]; then
        xcodes_version_str=$(xcodes list 2>/dev/null \
            | grep -E "^[[:space:]]*${XCODE_VERSION}([[:space:](]|$)" \
            | tail -1 \
            | sed 's/ ([^)]*)$//' \
            | sed 's/^[[:space:]]*//' \
            | sed 's/[[:space:]]*$//' \
            || true)
    fi

    if [ -z "${xcodes_version_str}" ]; then
        log_error "Could not find Xcode ${XCODE_VERSION} in xcodes list"
        log_info  "Run 'xcodes list' to see all available versions"
        return 1
    fi

    log_info "Resolved: '${xcodes_version_str}'"

    # ── 3. Download via xcodes (uses aria2 automatically when installed) ──────
    # xcodes detects aria2 in PATH and uses it with up to 16 connections,
    # which is 3-5x faster and avoids single-stream timeout issues entirely.
    log_info "Downloading via xcodes + aria2..."

    set +e
    xcodes download --use-fastlane-auth "${xcodes_version_str}"
    local xcodes_exit=$?
    set -e

    if [ "${xcodes_exit}" -ne 0 ]; then
        log_error "xcodes download failed (exit ${xcodes_exit})"
        log_warn  "Download Xcode ${XCODE_VERSION} manually to ~/Downloads/ and re-run."
        return 1
    fi
    log_success "Xcode ${XCODE_VERSION} downloaded"

    # ── Locate the downloaded archive ─────────────────────────────────────────
    # Older Xcode releases (roughly ≤ 7.x) ship as a .dmg disk image;
    # newer releases use the .xip format.  Search for whichever landed in
    # ~/Downloads so the same code path handles both automatically.
    local xip_file dmg_file
    xip_file=$(find ~/Downloads \
                    -name "Xcode-${XCODE_VERSION}*.xip" \
                    -o -name "Xcode_${XCODE_VERSION}*.xip" \
               2>/dev/null | head -1)
    dmg_file=$(find ~/Downloads \
                    -name "Xcode-${XCODE_VERSION}*.dmg" \
                    -o -name "Xcode_${XCODE_VERSION}*.dmg" \
               2>/dev/null | head -1)

    local extract_dir="${WORK_DIR}/xcode_extract"
    mkdir -p "${extract_dir}"

    if [ -n "${xip_file}" ]; then
        # ── .xip path (modern Xcode) ───────────────────────────────────────────
        log_success "Xcode archive (xip): ${xip_file}"
        log_info "Extracting Xcode via unxip (this will take several minutes)..."

        cd "${extract_dir}"
        unxip "${xip_file}"

        if [ ! -d "Xcode.app" ]; then
            log_error "Xcode.app not found after unxip extraction"
            exit 1
        fi

        log_info "Moving Xcode.app to /Applications/Xcode_${XCODE_VERSION}.app..."
        sudo mv "Xcode.app" "/Applications/Xcode_${XCODE_VERSION}.app"
        log_success "Xcode installed to /Applications/Xcode_${XCODE_VERSION}.app"

        log_info "Removing .xip file to save space..."
        rm "${xip_file}"

    elif [ -n "${dmg_file}" ]; then
        # ── .dmg path (legacy Xcode distributed as disk image) ────────────────
        log_success "Xcode archive (dmg): ${dmg_file}"
        log_info "Mounting Xcode DMG..."

        local dmg_mount_root
        dmg_mount_root=$(mktemp -d -t xcode_dmg_mount)
        TEMP_DIRS+=("${dmg_mount_root}")

        if ! hdiutil attach "${dmg_file}" \
                -mountroot "${dmg_mount_root}" \
                -nobrowse -quiet -readonly; then
            log_error "Failed to mount Xcode DMG: ${dmg_file}"
            exit 1
        fi

        # The volume name varies across releases; search for Xcode.app inside
        # any mounted volume, up to two directory levels deep.
        local xcode_app_src=""
        for vol in "${dmg_mount_root}"/*; do
            [ -d "${vol}" ] || continue
            MOUNTED_VOLS+=("${vol}")

            if [ -d "${vol}/Xcode.app" ]; then
                xcode_app_src="${vol}/Xcode.app"
                break
            fi

            # Some DMGs place Xcode.app inside a named sub-folder.
            local nested
            nested=$(find "${vol}" -maxdepth 2 -name "Xcode.app" -type d 2>/dev/null | head -1)
            if [ -n "${nested}" ]; then
                xcode_app_src="${nested}"
                break
            fi
        done

        if [ -z "${xcode_app_src}" ]; then
            log_error "Could not find Xcode.app inside the mounted DMG"
            exit 1
        fi

        log_info "Copying Xcode.app from DMG to /Applications/Xcode_${XCODE_VERSION}.app"
        log_warn "This may take several minutes..."
        sudo cp -R "${xcode_app_src}" "/Applications/Xcode_${XCODE_VERSION}.app"
        log_success "Xcode copied to /Applications/Xcode_${XCODE_VERSION}.app"

        # Unmount now that the copy is done; remove from tracking list so the
        # global cleanup handler does not try to unmount them a second time.
        log_info "Unmounting Xcode DMG..."
        for vol in "${MOUNTED_VOLS[@]+"${MOUNTED_VOLS[@]}"}"; do
            hdiutil detach "${vol}" 2>/dev/null || true
        done
        MOUNTED_VOLS=()

        log_info "Removing .dmg file to save space..."
        rm "${dmg_file}"

    else
        log_error "Could not find a downloaded Xcode archive for version ${XCODE_VERSION}"
        log_info "Searched ~/Downloads for files matching:"
        log_info "  Xcode-${XCODE_VERSION}*.xip  (modern)"
        log_info "  Xcode_${XCODE_VERSION}*.xip  (modern, alt naming)"
        log_info "  Xcode-${XCODE_VERSION}*.dmg  (legacy)"
        log_info "  Xcode_${XCODE_VERSION}*.dmg  (legacy, alt naming)"
        exit 1
    fi

    # ── Common post-install steps ──────────────────────────────────────────────
    export DEVELOPER_DIR="/Applications/Xcode_${XCODE_VERSION}.app"

    log_info "Accepting Xcode ${XCODE_VERSION} license (requires sudo)..."
    sudo DEVELOPER_DIR="${DEVELOPER_DIR}" xcodebuild -license accept
    log_success "Xcode license accepted"

    cd "${SCRIPT_DIR}"
}

################################################################################
# Xcode Version Detection Functions
################################################################################

determine_xcode_version() {
    log_step "Step 2: Determining Xcode Version for iOS SDK ${IOS_VERSION}"

    XCODE_VERSION=$(xcode_for_ios_sdk "${IOS_VERSION}")

    if [ -z "${XCODE_VERSION}" ]; then
        log_error "iOS SDK ${IOS_VERSION} is not in the known version table."
        log_info "Known SDKs: $(all_known_ios_sdks | tr '\n' ' ')"
        exit 1
    fi

    log_success "iOS SDK ${IOS_VERSION} → Xcode ${XCODE_VERSION}"
}

################################################################################
# Device Selection Functions
################################################################################

select_device_automatically() {
    log_step "Step 4: Automatically Selecting iPhone Device"

    log_info "Finding available devices for iOS ${IOS_VERSION}..."

    local device_list=""

    local all_devices_output
    all_devices_output=$(ipsw download ipsw --urls --version "${IOS_VERSION}" 2>&1 || true)

    if [ -n "${all_devices_output}" ] && ! echo "${all_devices_output}" | grep -q "filter flags matched 0 IPSWs"; then
        device_list=$(echo "${all_devices_output}" | grep -o 'iPhone[0-9]*,[0-9]*' || true | sort -u -V | tail -1)
    fi

    if [ -z "${device_list}" ]; then
        log_warn "Could not get device list via URLs, trying --device-list..."
        local temp_list
        temp_list=$(ipsw download ipsw --device-list --version "${IOS_VERSION}" 2>/dev/null || true)
        if [ -n "${temp_list}" ]; then
            # Filter to arm64 devices only (iPhone6,1+ = iPhone 6 = A8 = arm64 minimum)
            # Excludes iPhone5,x (armv7s/32-bit) and iPhone4,x (armv7/32-bit)
            device_list=$(echo "${temp_list}" | grep -oE 'iPhone[6-9][0-9]*,[0-9]+' || true | sort -V | tail -1)
        fi
    fi

    if [ -z "${device_list}" ]; then
        log_warn "Could not automatically determine device for iOS ${IOS_VERSION}"

        local major_version
        major_version=$(echo "${IOS_VERSION}" | cut -d. -f1)

        if [ "${major_version}" -ge 26 ]; then
            IPSW_DEVICE="iPhone16,2"
        elif [ "${major_version}" -ge 18 ]; then
            IPSW_DEVICE="iPhone15,3"
        elif [ "${major_version}" -ge 17 ]; then
            IPSW_DEVICE="iPhone14,3"
        elif [ "${major_version}" -ge 16 ]; then
            IPSW_DEVICE="iPhone14,2"
        elif [ "${major_version}" -ge 14 ]; then
            IPSW_DEVICE="iPhone12,5"
        elif [ "${major_version}" -ge 13 ]; then
            IPSW_DEVICE="iPhone11,4"
        elif [ "${major_version}" -ge 12 ]; then
            IPSW_DEVICE="iPhone11,4"
        elif [ "${major_version}" -ge 11 ]; then
            IPSW_DEVICE="iPhone10,6"
        elif [ "${major_version}" -ge 10 ]; then
            IPSW_DEVICE="iPhone9,4"
        else
            # iOS 9.x — iPhone 6s (A9, arm64). iPhone5,x/4,x are armv7s/32-bit
            # and would produce a cache incompatible with modern Theos toolchains.
            IPSW_DEVICE="iPhone8,2"
        fi
        log_info "Defaulting to ${IPSW_DEVICE} for iOS ${major_version}"
    else
        # From the filtered list, verify it's arm64 (model number >= iPhone6,1)
        local raw_device
        raw_device=$(echo "${device_list}" | head -1)
        local model_major
        model_major=$(echo "${raw_device}" | grep -oE 'iPhone([0-9]+),' | grep -oE '[0-9]+' || echo "0")
        if [ "${model_major}" -lt 6 ]; then
            log_warn "Auto-selected ${raw_device} is a 32-bit device — overriding to arm64 fallback"
            local major_version
            major_version=$(echo "${IOS_VERSION}" | cut -d. -f1)
            IPSW_DEVICE="iPhone8,2"  # iPhone 6s Plus, arm64, supports iOS 9+
        else
            IPSW_DEVICE="${raw_device}"
        fi
    fi

    # Verify IPSW availability
    log_info "Verifying IPSW availability for ${IPSW_DEVICE} with iOS ${IOS_VERSION}..."
    local verify_url
    verify_url=$(ipsw download ipsw --urls --version "${IOS_VERSION}" --device "${IPSW_DEVICE}" 2>&1 || true)

    if echo "${verify_url}" | grep -q "filter flags matched 0 IPSWs"; then
        log_warn "No IPSW found for ${IPSW_DEVICE} with iOS ${IOS_VERSION}"
        log_info "Trying to find any available device for iOS ${IOS_VERSION}..."

        local any_device
        any_device=$(ipsw download ipsw --urls --version "${IOS_VERSION}" 2>&1 | grep -o 'iPhone[0-9]*,[0-9]*' | head -1 || true)

        if [ -n "${any_device}" ]; then
            IPSW_DEVICE="${any_device}"
            log_success "Found available device: ${IPSW_DEVICE}"
        else
            log_error "Could not find any device with iOS ${IOS_VERSION} IPSW"
            exit 1
        fi
    fi

    # SDK name uses only the iOS version: iPhoneOS{version}
    FULL_SDK_NAME="iPhoneOS${IOS_VERSION}"
    log_success "SDK name: ${FULL_SDK_NAME}.sdk"
}

################################################################################
# IPSW Download and Extraction Functions
################################################################################

download_and_extract_ipsw() {
    log_step "Step 5: Downloading and Extracting IPSW"

    local ipsw_download_dir
    ipsw_download_dir=$(mktemp -d -t ipsw_download)
    TEMP_DIRS+=("${ipsw_download_dir}")

    local ipsw_extraction_dir
    ipsw_extraction_dir=$(mktemp -d -t ipsw_extract)
    TEMP_DIRS+=("${ipsw_extraction_dir}")

    log_info "Finding IPSW download URL for iOS ${IOS_VERSION} on ${IPSW_DEVICE}..."

    local ipsw_url
    ipsw_url=$(ipsw download ipsw --urls --version "${IOS_VERSION}" --device "${IPSW_DEVICE}" | head -1)

    if [ -z "${ipsw_url}" ]; then
        log_error "Failed to find IPSW download URL"
        exit 1
    fi

    log_info "IPSW URL: ${ipsw_url}"

    log_info "Downloading IPSW (this may take a while)..."
    aria2c --dir "${ipsw_download_dir}" "${ipsw_url}"

    log_success "IPSW downloaded successfully"

    log_info "Extracting DMG files from IPSW..."
    unzip -q -d "${ipsw_extraction_dir}" "${ipsw_download_dir}"/*.ipsw "*.dmg"

    log_success "DMG files extracted"

    IPSW_EXTRACTION_DIR="${ipsw_extraction_dir}"
    IPSW_DOWNLOAD_DIR="${ipsw_download_dir}"
}

################################################################################
# dyld Shared Cache Extraction Functions
################################################################################

find_dyld_shared_cache() {
    log_step "Step 6: Locating dyld Shared Cache"

    local dyld_extract_dir="${WORK_DIR}/dyld_extracted"
    mkdir -p "${dyld_extract_dir}"

    local ipsw_file
    ipsw_file=$(find "${IPSW_DOWNLOAD_DIR}" -name "*.ipsw" -type f 2>/dev/null | head -1)

    if [ -z "${ipsw_file}" ]; then
        log_error "Could not find downloaded IPSW file in ${IPSW_DOWNLOAD_DIR}"
        exit 1
    fi

    log_info "IPSW file: ${ipsw_file}"

    # Ordered list of DSC basenames to try – arm64e (iOS 14+), arm64 (iOS 11–13),
    # armv7s / armv7 (iOS 9–10).  We try all so older devices are handled.
    local dsc_candidates=("dyld_shared_cache_arm64e" "dyld_shared_cache_arm64" "dyld_shared_cache_armv7s" "dyld_shared_cache_armv7")

    # Temp file to capture ipsw stderr so we can log the real error if all methods fail
    local ipsw_err_log
    ipsw_err_log=$(mktemp /tmp/ipsw_err_XXXX.log)
    TEMP_DIRS+=("${ipsw_err_log}")

    # Helper: scan dyld_extract_dir for any primary cache file
    _find_extracted_cache() {
        local candidate
        for candidate in "${dsc_candidates[@]}"; do
            local hit
            hit=$(find "${dyld_extract_dir}" \
                -name "${candidate}" \
                -not -name "*.dyldlinkedit" \
                -not -name "*.dylddata" \
                -not -name "*.symbols" \
                -not -name "*.[0-9]*" \
                -type f 2>/dev/null | head -1)
            if [ -n "${hit}" ]; then
                log_success "Found dyld cache (${candidate}): ${hit}"
                DYLD_CACHE_PATH="${hit}"
                RESOLVED_DSC_BASENAME="${candidate}"
                return 0
            fi
        done
        return 1
    }

    # ── Method 1a: ipsw extract --dyld, no arch (auto-detect) ────────────────
    # For old IPSWs (iOS 9–13), passing --dyld-arch causes ipsw to hang or skip
    # if that arch isn't present. Auto-detect mode is tried first.
    # Timeout: 120s — old IPSW extraction should complete well within that.
    log_info "Attempting ipsw extract --dyld (auto-detect arch)..."
    if timeout 120 ipsw extract --dyld -o "${dyld_extract_dir}" "${ipsw_file}" 2>"${ipsw_err_log}"; then
        if _find_extracted_cache; then
            rm -f "${ipsw_err_log}"
            return 0
        fi
    fi
    if [ -s "${ipsw_err_log}" ]; then
        log_warn "ipsw auto-detect error: $(head -3 "${ipsw_err_log}")"
    fi

    # ── Method 1b: ipsw extract --dyld, explicit arch variants ───────────────
    local arch_candidates=("arm64e" "arm64" "armv7s" "armv7")
    local arch
    for arch in "${arch_candidates[@]}"; do
        log_info "  Trying --dyld-arch ${arch} (timeout 120s)..."
        if timeout 120 ipsw extract --dyld --dyld-arch "${arch}" -o "${dyld_extract_dir}" "${ipsw_file}" 2>"${ipsw_err_log}"; then
            if _find_extracted_cache; then
                rm -f "${ipsw_err_log}"
                return 0
            fi
        fi
        if [ -s "${ipsw_err_log}" ]; then
            log_warn "  ipsw error (arch=${arch}): $(head -1 "${ipsw_err_log}")"
        fi
    done
    log_warn "ipsw extract --dyld: no cache found for any arch — trying DMG mount method..."
    log_warn "(iOS 9–12 root filesystems are img4-encrypted; hdiutil mount may also fail)"

    # Method 2: Mount DMGs and search for the cache at known paths.
    # Build the list of locations to probe for every candidate basename.
    local dyld_cache_path=""

    for dmg_file in "${IPSW_EXTRACTION_DIR}"/*.dmg; do
        [ -f "${dmg_file}" ] || continue

        local dmg_name
        dmg_name=$(basename "${dmg_file}")
        log_info "Checking DMG: ${dmg_name}"

        local dmg_mount_root
        dmg_mount_root=$(mktemp -d -t dmg_mount)
        TEMP_DIRS+=("${dmg_mount_root}")

        if ! hdiutil attach "${dmg_file}" -mountroot "${dmg_mount_root}" -nobrowse -quiet -readonly 2>/dev/null; then
            log_warn "  Could not mount ${dmg_name} (expected for some DMG types)"
            continue
        fi

        for mount_vol in "${dmg_mount_root}"/*; do
            [ -d "${mount_vol}" ] || continue
            MOUNTED_VOLS+=("${mount_vol}")
            log_info "  Scanning volume: $(basename "${mount_vol}")"

            for candidate in "${dsc_candidates[@]}"; do
                local cache_locations=(
                    "System/Library/Caches/com.apple.dyld/${candidate}"
                    "System/Cryptexes/OS/System/Library/Caches/com.apple.dyld/${candidate}"
                    "System/Library/dyld/${candidate}"
                    "private/preboot/Cryptexes/OS/System/Library/Caches/com.apple.dyld/${candidate}"
                )
                for cache_location in "${cache_locations[@]}"; do
                    if [ -e "${mount_vol}/${cache_location}" ]; then
                        dyld_cache_path="${mount_vol}/${cache_location}"
                        log_success "Found ${candidate} at: ${dyld_cache_path}"
                        DYLD_CACHE_PATH="${dyld_cache_path}"
                        RESOLVED_DSC_BASENAME="${candidate}"
                        return 0
                    fi
                done
            done

            # Deep search: find any dyld_shared_cache_* primary file (no sub-file suffixes)
            log_info "  Deep searching volume for dyld_shared_cache_*..."
            local deep_match
            deep_match=$(find "${mount_vol}" \
                -name "dyld_shared_cache_arm*" \
                -not -name "*.dyldlinkedit" \
                -not -name "*.dylddata" \
                -not -name "*.symbols" \
                -not -name "*.[0-9]*" \
                -type f 2>/dev/null | head -1)
            if [ -n "${deep_match}" ]; then
                log_success "Found by deep search: ${deep_match}"
                DYLD_CACHE_PATH="${deep_match}"
                RESOLVED_DSC_BASENAME="$(basename "${deep_match}")"
                return 0
            fi

            hdiutil detach "${mount_vol}" 2>/dev/null || true
        done
    done

    log_error "Failed to find a dyld shared cache in IPSW (tried: ${dsc_candidates[*]})"
    exit 1
}

################################################################################
# dsc_extractor_client Build Functions
#
# For iOS < 16, ipsw cannot extract the dyld shared cache directly.  The
# reliable alternative (used by the official Theos workflow) is to compile a
# tiny C shim that calls Apple's own dsc_extractor.bundle (bundled with the
# Xcode platform) to extract every dylib from the cache into a symbols dir.
# tbd then processes those extracted dylibs — a much more reliable path than
# feeding the raw DSC file to tbd for older cache formats.
################################################################################

# Source for the dsc_extractor_client shim (verbatim from Apple's dyld repo,
# identical to the copy in the official Theos sdks workflow).
DSC_EXTRACTOR_CLIENT_SRC='
// modified from Apple'\''s dyld
// https://github.com/apple-oss-distributions/dyld/blob/18d3cb0/other-tools/dsc_extractor.cpp#L1080-L1111
#include <dlfcn.h>
#include <stddef.h>
#include <stdio.h>
typedef int (*extractor_proc)(const char *shared_cache_file_path,
                               const char *extraction_root_path,
                               void (^progress)(unsigned current, unsigned total));
int main(int argc, const char *argv[]) {
    if (argc != 4) {
        fprintf(stderr, "usage: %s <path-to-dsc_extractor-bundle> <path-to-cache-file> <path-to-device-dir>\n", argv[0]);
        return 1;
    }
    void *const handle = dlopen(argv[1], RTLD_LAZY);
    if (handle == NULL) {
        fprintf(stderr, "dsc_extractor.bundle could not be loaded\n");
        return 1;
    }
    extractor_proc const proc = (extractor_proc)dlsym(handle, "dyld_shared_cache_extract_dylibs_progress");
    if (proc == NULL) {
        fprintf(stderr, "%s did not have dyld_shared_cache_extract_dylibs_progress symbol\n", argv[1]);
        return 1;
    }
    int result = proc(argv[2], argv[3], ^(unsigned current, unsigned total) {
        unsigned const c = current + 1;
        printf("  %u/%u%c", c, total, (c == total) ? '\''\n'\'' : '\''\r'\'');
        fflush(stdout);
    });
    dlclose(handle);
    return result;
}
'

build_dsc_extractor_client() {
    log_step "Step 7a: Building dsc_extractor_client"

    # Shared binary location across all versions (only compiled once per run)
    local client_dir="${SCRIPT_DIR}/.dsc_extractor_client"
    local client_bin="${client_dir}/dsc_extractor_client"

    if [ -f "${client_bin}" ]; then
        log_success "dsc_extractor_client already built"
        DSC_EXTRACTOR_CLIENT_PATH="${client_bin}"
        return 0
    fi

    mkdir -p "${client_dir}"
    local src_file="${client_dir}/dsc_extractor_client.c"

    printf '%s' "${DSC_EXTRACTOR_CLIENT_SRC}" > "${src_file}"

    log_info "Compiling dsc_extractor_client..."
    # Use the active Xcode's clang. DEVELOPER_DIR must point to Contents/Developer
    # (not the .app root) for xcrun to work; export_DEVELOPER_DIR is set by
    # download_and_extract_xcode to the .app path, so we resolve it explicitly.
    local dev_dir
    dev_dir=$(xcode-select -p 2>/dev/null || true)
    [ -z "${dev_dir}" ] && dev_dir="${DEVELOPER_DIR:-}/Contents/Developer"
    local clang_bin
    clang_bin=$(DEVELOPER_DIR="${dev_dir}" xcrun --find clang 2>/dev/null || echo "clang")
    if "${clang_bin}" -o "${client_bin}" "${src_file}" 2>/dev/null; then
        log_success "dsc_extractor_client compiled: ${client_bin}"
        DSC_EXTRACTOR_CLIENT_PATH="${client_bin}"
    else
        log_warn "Failed to compile dsc_extractor_client — will fall back to tbd direct mode"
        DSC_EXTRACTOR_CLIENT_PATH=""
    fi
}

################################################################################
# tbd Tool Build Functions
#
# FIX: The previously-pinned commit f0ae164 predates the split-cache format
# used by iOS 15+ IPSWs.  When pointed at a directory containing the primary
# dyld_shared_cache_arm64e plus its dozens of sub-files (.01, .02 … .symbols,
# .dyldlinkedit, .dylddata), it emits "has invalid images" for every sub-file
# and then reports "No new .tbd files were created".
#
# Fix 1 – use the latest tbd HEAD (active maintenance; split-cache aware).
# Fix 2 – in create_patched_sdk(), we pass tbd a clean one-file directory
#          containing only the primary cache, avoiding sub-file confusion.
################################################################################

build_tbd_tool() {
    log_step "Step 7: Building tbd Tool"

    # Shared tbd dir across all versions (only built once)
    local tbd_dir="${SCRIPT_DIR}/.tbd_tool"

    if [ -f "${tbd_dir}/bin/tbd" ]; then
        log_success "tbd tool already built"
        TBD_TOOL_PATH="${tbd_dir}/bin/tbd"
        return 0
    fi

    log_info "Cloning tbd repository..."
    git clone https://github.com/leptos-null/tbd.git "${tbd_dir}"

    cd "${tbd_dir}"
    # NOTE: Do NOT pin to a specific commit here.  Old commits (e.g. f0ae164)
    # do not understand the split dyld shared cache format introduced in
    # iOS 15 and extended heavily in iOS 18 (60+ sub-files per cache).
    # Using HEAD ensures split-cache support is available.
    log_info "Building tbd tool (latest)..."
    env -u DEVELOPER_DIR make bin/tbd

    if [ ! -f "bin/tbd" ]; then
        log_error "Failed to build tbd tool"
        exit 1
    fi

    log_success "tbd tool built successfully"
    TBD_TOOL_PATH="${tbd_dir}/bin/tbd"

    cd "${SCRIPT_DIR}"
}

################################################################################
# SDK Patching Functions
#
# FIX: create_patched_sdk.sh (theos) passes its first argument — the symbols
# directory — directly to tbd.  tbd then processes EVERY file in that
# directory.  When ipsw extract --dyld is used, the extraction directory
# contains the primary cache PLUS all split sub-files
# (dyld_shared_cache_arm64e.01 … .symbols, .dyldlinkedit, .dylddata …).
# tbd correctly parses only the primary file but emits a noisy
# "has invalid images" warning for each sub-file, and on some tbd versions
# the sub-file failures suppress output even for the primary file.
#
# Fix: create a minimal one-file directory containing a hard-link (or copy)
# of just the primary cache and pass THAT to the patching script.  This
# eliminates all sub-file warnings and ensures tbd focuses solely on the
# correct input.
################################################################################

create_patched_sdk() {
    log_step "Step 8: Creating Patched SDK"

    SDK_OUTPUT_PATH="${WORK_DIR}/${FULL_SDK_NAME}.sdk"

    # Download patching script once per work dir
    local patch_script="${WORK_DIR}/create_patched_sdk.sh"

    if [ ! -f "${patch_script}" ]; then
        log_info "Downloading SDK patching script from Theos repository..."
        curl -fsSL -o "${patch_script}" \
            https://raw.githubusercontent.com/theos/sdks/refs/heads/master/tools/create_patched_sdk.sh
        chmod +x "${patch_script}"
    fi

    if [ ! -s "${patch_script}" ]; then
        log_error "Failed to download patching script"
        exit 1
    fi

    log_info "Getting SDK paths from Xcode..."

    # ── Resolve the active Xcode developer directory (three-step fallback) ────
    # Step 1: expected versioned path (the happy path on GitHub runners)
    local xcode_dev_dir="/Applications/Xcode_${XCODE_VERSION}.app/Contents/Developer"

    if [ ! -d "${xcode_dev_dir}" ]; then
        log_warn "Xcode not found at ${xcode_dev_dir} — trying xcode-select -p..."

        # Step 2: ask the system which Xcode is currently active
        local selected_dev_dir
        selected_dev_dir=$(xcode-select -p 2>/dev/null || true)
        if [ -d "${selected_dev_dir}" ]; then
            log_info "xcode-select -p → ${selected_dev_dir}"
            xcode_dev_dir="${selected_dev_dir}"
        else
            log_warn "xcode-select -p returned nothing — scanning /Applications..."

            # Step 3: take the highest-versioned Xcode*.app in /Applications
            local scanned_app
            scanned_app=$(find /Applications -maxdepth 1 -name "Xcode*.app" -type d 2>/dev/null \
                          | sort -V | tail -1)
            if [ -n "${scanned_app}" ] && [ -d "${scanned_app}/Contents/Developer" ]; then
                xcode_dev_dir="${scanned_app}/Contents/Developer"
                log_info "Found via scan: ${xcode_dev_dir}"
            else
                log_error "Could not locate any Xcode installation. Installed apps:"
                find /Applications -maxdepth 1 -name "Xcode*.app" 2>/dev/null | sed 's/^/    /' || true
                exit 1
            fi
        fi
    fi

    log_info "Setting active developer directory → ${xcode_dev_dir}"
    sudo xcode-select -s "${xcode_dev_dir}" 2>/dev/null || true

    local base_sdk_path
    base_sdk_path=$(DEVELOPER_DIR="${xcode_dev_dir}" xcrun --sdk "${XCRUN_SDK_NAME}" --show-sdk-path 2>/dev/null) || true

    # Filesystem fallback
    if [ -z "${base_sdk_path}" ]; then
        log_warn "xcrun returned no SDK path — scanning Xcode installation directly..."
        local sdks_dir="${xcode_dev_dir}/Platforms/iPhoneOS.platform/Developer/SDKs"
        if [ -d "${sdks_dir}" ]; then
            base_sdk_path=$(find "${sdks_dir}" -maxdepth 1 -name "iPhoneOS*.sdk" -type d 2>/dev/null \
                            | sort -V | tail -1) || true
            if [ -n "${base_sdk_path}" ]; then
                log_info "Found SDK via filesystem scan: ${base_sdk_path}"
            fi
        fi
    fi

    if [ -z "${base_sdk_path}" ]; then
        log_error "Failed to locate base SDK for Xcode ${XCODE_VERSION}"
        log_info  "Searched: xcrun --sdk ${XCRUN_SDK_NAME} --show-sdk-path"
        log_info  "Searched: ${xcode_dev_dir}/Platforms/iPhoneOS.platform/Developer/SDKs/"
        exit 1
    fi

    # ── Platform path (needed for dsc_extractor.bundle) ───────────────────────
    PLATFORM_PATH=$(DEVELOPER_DIR="${xcode_dev_dir}" xcrun --sdk "${XCRUN_SDK_NAME}" --show-sdk-platform-path 2>/dev/null) || true
    if [ -z "${PLATFORM_PATH}" ]; then
        PLATFORM_PATH="${xcode_dev_dir}/Platforms/iPhoneOS.platform"
        log_warn "xcrun did not return platform path; assuming ${PLATFORM_PATH}"
    fi

    # ── Choose the actual DSC basename that was found ─────────────────────────
    local active_dsc_basename="${RESOLVED_DSC_BASENAME:-${DSC_BASENAME}}"

    # ── Strategy: prefer dsc_extractor_client (extracts full dylib tree) ──────
    # The extractor approach is more reliable for older cache formats (pre-iOS 16).
    # For modern split caches (iOS 15+) tbd handles them natively via direct mode.
    local symbols_input_dir=""

    local dsc_bundle="${PLATFORM_PATH}/usr/lib/dsc_extractor.bundle"

    local major_ver
    major_ver=$(echo "${IOS_VERSION}" | cut -d. -f1)

    if [ -n "${DSC_EXTRACTOR_CLIENT_PATH}" ] && [ -f "${dsc_bundle}" ]; then
        log_info "Using dsc_extractor_client approach (reliable for all iOS versions)"
        log_info "  Bundle:   ${dsc_bundle}"
        log_info "  Cache:    ${DYLD_CACHE_PATH}"

        local extracted_dir="${WORK_DIR}/dyld_symbols"
        mkdir -p "${extracted_dir}"

        if "${DSC_EXTRACTOR_CLIENT_PATH}" \
                "${dsc_bundle}" \
                "${DYLD_CACHE_PATH}" \
                "${extracted_dir}" 2>&1 | tail -5; then
            local dylib_count
            dylib_count=$(find "${extracted_dir}" -name "*.dylib" 2>/dev/null | wc -l | tr -d ' ')
            if [ "${dylib_count}" -gt 0 ]; then
                log_success "dsc_extractor extracted ${dylib_count} dylibs → ${extracted_dir}"
                symbols_input_dir="${extracted_dir}"
            else
                log_warn "dsc_extractor produced no dylibs; falling back to direct DSC mode"
            fi
        else
            log_warn "dsc_extractor_client failed; falling back to direct DSC mode"
        fi
    else
        if [ -z "${DSC_EXTRACTOR_CLIENT_PATH}" ]; then
            log_warn "dsc_extractor_client not available"
        fi
        if [ ! -f "${dsc_bundle}" ]; then
            log_warn "dsc_extractor.bundle not found at: ${dsc_bundle}"
        fi
    fi

    # ── Fallback: isolate primary cache file and let tbd parse it directly ────
    # We put only the primary cache (no sub-files) in a dedicated directory so
    # tbd does not choke on the dozens of split sub-cache files.
    if [ -z "${symbols_input_dir}" ]; then
        log_info "Using direct DSC mode (tbd parses cache directly)"
        local tbd_input_dir="${WORK_DIR}/dyld_for_tbd"
        mkdir -p "${tbd_input_dir}"
        ln "${DYLD_CACHE_PATH}" "${tbd_input_dir}/${active_dsc_basename}" 2>/dev/null \
            || cp "${DYLD_CACHE_PATH}" "${tbd_input_dir}/${active_dsc_basename}"
        log_info "Isolated primary dyld cache → ${tbd_input_dir}/${active_dsc_basename}"
        symbols_input_dir="${tbd_input_dir}"
    fi

    log_info "Base SDK path:  ${base_sdk_path}"
    log_info "Symbols input:  ${symbols_input_dir}"
    log_info "tbd tool:       ${TBD_TOOL_PATH}"
    log_info "Output SDK:     ${SDK_OUTPUT_PATH}"

    log_info "Running SDK patching script (this may take several minutes)..."

    "${patch_script}" \
        "${symbols_input_dir}" \
        "${SDK_OUTPUT_PATH}" \
        "${base_sdk_path}" \
        "${TBD_TOOL_PATH}" || true

    if [ ! -d "${SDK_OUTPUT_PATH}" ]; then
        log_error "Patching script did not produce output SDK at: ${SDK_OUTPUT_PATH}"
        exit 1
    fi

    local tbd_count
    tbd_count=$(find "${SDK_OUTPUT_PATH}" -name "*.tbd" 2>/dev/null | wc -l | tr -d ' ')
    if [ "${tbd_count}" -eq 0 ]; then
        log_warn "No .tbd stubs were generated — the SDK contains only Xcode headers."
        log_warn "This usually means tbd could not parse the dyld shared cache."
        log_warn "The SDK may still work for compilation but will be missing private symbols."
    else
        log_success "SDK contains ${tbd_count} .tbd stub file(s)"
    fi

    log_success "Patched SDK created at: ${SDK_OUTPUT_PATH}"
}

################################################################################
# Xcode Removal Functions
################################################################################

remove_xcode() {
    # Never remove a Xcode that was already on the runner before we started —
    # it belongs to the runner image and other jobs may depend on it.
    if [ "${XCODE_WAS_PREINSTALLED:-false}" = "true" ]; then
        log_info "Xcode was pre-installed on this runner — leaving it in place."
        return 0
    fi

    local xcode_app="/Applications/Xcode_${XCODE_VERSION}.app"

    if [ ! -d "${xcode_app}" ]; then
        log_info "Xcode ${XCODE_VERSION} not found at ${xcode_app} — nothing to remove."
        return 0
    fi

    log_step "Removing Xcode ${XCODE_VERSION}"
    log_info "Permanently deleting ${xcode_app} to reclaim disk space..."

    if sudo rm -rf "${xcode_app}"; then
        log_success "Xcode ${XCODE_VERSION} removed successfully."
    else
        log_warn "Failed to remove Xcode ${XCODE_VERSION}. You may need to delete it manually:"
        log_warn "  sudo rm -rf \"${xcode_app}\""
    fi

    unset DEVELOPER_DIR || true
}

################################################################################
# Finalization Functions
################################################################################

finalize_sdk() {
    log_step "Finalizing SDK"

    local final_output="${SCRIPT_DIR}/${FULL_SDK_NAME}.sdk"

    if [ -d "${final_output}" ]; then
        log_warn "Output SDK already exists: ${final_output}"
        if [ "${ALL_VERSIONS}" = true ]; then
            log_skip "Overwriting existing SDK in --all mode: ${final_output}"
            rm -rf "${final_output}"
        else
            read -p "Overwrite? (y/n): " overwrite
            if [[ ! "${overwrite}" =~ ^[Yy]$ ]]; then
                log_info "Keeping SDK in work directory: ${SDK_OUTPUT_PATH}"
                # Still remove Xcode since the SDK was already present
                remove_xcode
                return 0
            fi
            rm -rf "${final_output}"
        fi
    fi

    log_info "Copying SDK to final location..."
    cp -R "${SDK_OUTPUT_PATH}" "${final_output}"

    log_success "SDK copied to: ${final_output}"

    echo ""
    log_info "SDK Information:"
    echo "  Location: ${final_output}"
    echo "  Size:     $(du -sh "${final_output}" | cut -f1)"
    echo ""

    log_success "SDK creation complete: ${FULL_SDK_NAME}.sdk"

    # SDK is safely on disk — permanently remove the Xcode installation
    remove_xcode
}

################################################################################
# Single-version processing pipeline
# Wraps the whole workflow so --all can call it per version with error isolation.
################################################################################

process_version() {
    local version="$1"

    IOS_VERSION="${version}"
    WORK_DIR="${SCRIPT_DIR}/sdk_build_${version}_$(date +%Y%m%d_%H%M%S)"

    # SDK already on disk? Skip.
    if sdk_already_exists "${version}"; then
        log_skip "iPhoneOS${version}.sdk already exists — skipping."
        return 0
    fi

    mkdir -p "${WORK_DIR}"
    log_info "Work directory: ${WORK_DIR}"

    # Each step may exit 1 on failure; caller catches that with || true + continue
    determine_xcode_version
    if ! download_and_extract_xcode; then
        log_warn "Skipping iOS ${version} — Xcode could not be located or downloaded."
        return 1
    fi
    select_device_automatically
    download_and_extract_ipsw
    find_dyld_shared_cache
    build_dsc_extractor_client
    build_tbd_tool
    create_patched_sdk
    finalize_sdk

    # Clean up this version's work dir and temp state
    for vol in "${MOUNTED_VOLS[@]+"${MOUNTED_VOLS[@]}"}"; do
        hdiutil detach "${vol}" 2>/dev/null || true
    done
    MOUNTED_VOLS=()

    for dir in "${TEMP_DIRS[@]+"${TEMP_DIRS[@]}"}"; do
        rm -rf "${dir}"
    done
    TEMP_DIRS=()

    rm -rf "${WORK_DIR}"
}

################################################################################
# All-versions batch download
################################################################################

download_all_sdks() {
    log_step "Batch Mode: Downloading All iOS SDKs (>= 9.3)"

    local versions
    versions=$(get_all_ios_versions)

    if [ -z "${versions}" ]; then
        log_error "Could not retrieve iOS version list. Check your internet connection."
        exit 1
    fi

    local total
    total=$(echo "${versions}" | wc -l | tr -d ' ')
    local current=0
    local skipped=0
    local failed=0
    local succeeded=0

    echo ""
    log_info "Found ${total} iOS SDK version(s) to process:"
    echo "${versions}" | while read -r v; do echo "  - iOS ${v}"; done
    echo ""

    for version in ${versions}; do
        current=$((current + 1))
        echo ""
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}  Processing iOS ${version}  [${current}/${total}]${NC}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

        # Check existence before running (faster skip path)
        if sdk_already_exists "${version}"; then
            log_skip "iPhoneOS${version}.sdk already present — skipping."
            skipped=$((skipped + 1))
            reset_version_state
            continue
        fi

        # Run with error isolation: failures are logged but do not abort the batch
        if process_version "${version}"; then
            succeeded=$((succeeded + 1))
        else
            log_warn "iOS ${version}: processing failed — skipping to next version."
            failed=$((failed + 1))
        fi

        reset_version_state
    done

    echo ""
    echo "================================================================"
    echo "                 Batch Processing Complete"
    echo "================================================================"
    echo ""
    echo "  Total versions found : ${total}"
    echo "  Successfully built   : ${succeeded}"
    echo "  Skipped (exist/N/A)  : ${skipped}"
    echo "  Failed               : ${failed}"
    echo ""
    echo "SDKs are located in: ${SCRIPT_DIR}"
    ls -1d "${SCRIPT_DIR}"/iPhoneOS*.sdk 2>/dev/null | while read -r s; do
        echo "  $(basename "${s}") ($(du -sh "${s}" | cut -f1))"
    done
    echo ""
}

################################################################################
# Usage and Help Functions
################################################################################

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Create patched iOS SDK(s). Specify an iOS version or use --all to download
every SDK from iPhoneOS9.3 onwards. SDKs are named iPhoneOS{version}.sdk.

OPTIONS:
    -i, --ios VERSION           iOS version to build (e.g., 16.5, 18.2)
    -a, --all                   Download ALL SDKs starting from iOS 9.3
    -h, --help                  Display this help message

NAMING CONVENTION:
    SDKs are always named:  iPhoneOS{version}.sdk
    Examples:               iPhoneOS9.3.sdk
                            iPhoneOS18.2.sdk
                            iPhoneOS26.3.sdk

SKIP LOGIC (--all mode):
    - If iPhoneOS{version}.sdk already exists in the script directory → SKIP
    - If no Xcode / IPSW is found for a version                       → SKIP
    - Processing continues with the next version on any failure

EXAMPLES:
    # Interactive mode (prompts for iOS version)
    $(basename "$0")

    # Build a specific SDK
    $(basename "$0") -i 18.2
    # → creates iPhoneOS18.2.sdk

    # Download ALL SDKs from iOS 9.3 to latest
    $(basename "$0") --all
    # → creates iPhoneOS9.3.sdk, iPhoneOS10.0.sdk, ..., iPhoneOS26.3.sdk
    # → skips any SDK that already exists on disk
    # → skips any iOS version for which no IPSW/Xcode can be found

REQUIREMENTS:
    - macOS with Homebrew installed
    - ~50 GB free disk space (more for --all)
    - Internet connection

The script automatically installs: unxip, xcodes, ipsw, aria2

KNOWN iOS SDK VERSIONS (read from sdk_map.json — run map_sdks.py to update):
$(all_known_ios_sdks 2>/dev/null | tr '\n' '  ' || echo "  (run map_sdks.py to generate the map)")
EOF
}

################################################################################
# Main Script Logic
################################################################################

main() {
    echo ""
    echo "================================================================"
    echo "     iOS SDK Patcher - Automated SDK Builder"
    echo "================================================================"
    echo ""

    # Parse command-line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -i|--ios)
                IOS_VERSION="$2"
                shift 2
                ;;
            -a|--all)
                ALL_VERSIONS=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Always ensure tools are present first
    install_required_tools

    # Ensure the Xcode↔iOS SDK map is available (may auto-generate via map_sdks.py)
    ensure_sdk_map

    # --all mode: batch processing, ignores -i
    if [ "${ALL_VERSIONS}" = true ]; then
        if [ -n "${IOS_VERSION}" ]; then
            log_warn "--all mode ignores the --ios flag. Building all versions."
        fi
        download_all_sdks
        return 0
    fi

    # Single-version mode
    if [ -z "${IOS_VERSION}" ]; then
        prompt_for_inputs
    fi

    validate_inputs

    # Check if already built
    if sdk_already_exists "${IOS_VERSION}"; then
        log_warn "iPhoneOS${IOS_VERSION}.sdk already exists in ${SCRIPT_DIR}"
        read -p "Re-build it anyway? (y/n): " rebuild
        if [[ ! "${rebuild}" =~ ^[Yy]$ ]]; then
            log_info "Nothing to do."
            exit 0
        fi
    fi

    WORK_DIR="${SCRIPT_DIR}/sdk_build_${IOS_VERSION}_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "${WORK_DIR}"
    log_info "Work directory: ${WORK_DIR}"

    determine_xcode_version
    if ! download_and_extract_xcode; then
        log_error "Xcode could not be located or downloaded for iOS SDK ${IOS_VERSION}."
        exit 1
    fi
    select_device_automatically
    download_and_extract_ipsw
    find_dyld_shared_cache
    build_dsc_extractor_client
    build_tbd_tool
    create_patched_sdk
    finalize_sdk

    echo ""
    echo "================================================================"
    echo "                        SUCCESS!"
    echo "================================================================"
    echo ""
    echo "Your patched SDK is ready at:"
    echo "  ${SCRIPT_DIR}/${FULL_SDK_NAME}.sdk"
    echo ""
    echo "Use this SDK with Theos or other iOS development tools."
    echo ""
}

main "$@"